# 1. OOP란?

* 현실 세계를 프로그래밍으로 옮겨와 사물을 객체로 보고 그 객체의 특징과 기능을 뽑아 프로그래밍하는 기법.
* 객체를 연결시켜 프로그래밍하면 상속, 캡슐화, 다형성을 이용해 코드 재사용성을 증가시키고 유지보수를 감소시켜주는 장점.

## 상속

* 자식 클래스가 부모 클래스의 필드와 메소드를 물려받는 것.
* private 필드와 메소드는 상속 불가.
* 중복된 코드 줄일 수 있고, 유지보수가 편리

## 다형성

* 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것.(오버로딩, 오버라이딩)
* 하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것.

## 캡슐화

* 객체접근에 있어서 정보를 숨기고 객체의 연산을 통해서만 접근이 가능하게 하는 것.
* 유지보수나 확장시 캡슐화를 통해 오류의 범위를 최소화 할 수 있다.

# 2. 자바의 메모리 영역

* static 영역
* static 변수, 전역 변수, 코드에서 사용되는 클래스 정보들이 올라감.
* 프로그램 종료시 까지 메모리에 남아있게 된다.

* 스택
* 지역 변수, 메소드 등이 할당되는 영역

* 힙
* new 연산자를 통해 동적할당된 객체들이 저장되고, 메모리는 가비지 컬렉션에 의해 관리.

## static

* static 영역에 변수가 올라가 프로그램 종료시까지 메모리에 남아있게 됨.
* 객체의 생성 없이 바로 접근 가능.

## JVM

* 자바와 운영체제 사이의 중계자 역할을 함, 자바가 운영체제 종류에 상관없이 돌아갈 수 있도록 함.
* 메모리를 자동으로 관리(GC)

* 자바 실행 과정
* Java Compiler에 의해 Java Source(.java) 파일은 Byte Code(.class)로 변환.
* Class Loader는 변환된 Byte Code 파일을 JVM 내로 class를 로드.
* Excution Engine은 JVM 메모리에 배치된 Byte Code들을 명령어 단위로 실행.
* GC는 더 이상 참조되지 않거나 null인 객체의 메모리를 해제시켜 공간 확보.
* Runtime Data Area는 JVM 메모리로 Java Application이 실행하면서 할당받은 메모리영역이다.

## 가비지 컬렉터

* Java Application은 JVM 위에서 구동, JVM에서는 Java Application이 사용하는 메모리를 관리하는데 JVM의 기능 중
더 이상 사용하지 않는 객체를 청소하여 공간을 확보하는 가비지 컬렉터가 있다.

* GC 과정
* 객체가 생성되어 Eden 영역에 올라감.
* Eden 영역이 꽉 차면 Servior 영역으로 넘어감, 객체의 크기가 Servior 영역보다 크다면 Old 영역으로 이동
* Old 영역에 들어간 객체는 풀 GC, 메이저 GC가 발생하지 않는한 GC되지 않음.

* 풀 GC : 메모리 전체를 대상으로 하는 GC
* 메이저 GC : Old, Perm 영역에서 발생하는 GC
* 마이너 GC : Young 영역에서 발생하는 GC

* GC 방식
* Serial Collector
* 하나의 CPU로 Young 영역과 Old 영역을 연속적으로 처리, 컬렉션이 수행될 때 애플리케이션이 정지.
* Old 영역에서 쓰레기 객체를 한 곳으로 모아 삭제.

* Parallel Collector
* 다른 CPU가 GC의 진행시간 동안 대기 상태로 남아 있는 것을 최소화
* Serial Collector의 Young 영역에서 진행하는 컬렉션을 병렬 방식으로 처리해 GC의 부하를 줄이고 성능을 향상.

## 3. 인터페이스

* 모든 메소드가 추상 메소드로 이루어진 클래스.
* 공동 작업시 충동을 방지하기 위해 사용한다.
* A,B가 각각 a번역, b번역 메소드 코드를 작성할 때 인터페이스를 상속받아 사용하게 된다면 클래스의 이름만 알고 있다면
번역 메소드를 호출했을 때 어떤 번역 기능을 하는지 기대할 수 있다는 것.

* 교체 용이
* 다른 방식으로 바꾸고 싶을 때, 클래스를 개발해서 이름만 교체하면 되므로 간편하다.

* 다중 상속
* 필요한 인터페이스를 상속 받아서 구현하면 여러 기능들을 구조적으로 포함.

## 4. 메모리 상수풀 영역

* 힙 영역의 고정 영역에 생성되어 프로그램 종료시까지 계속 유지되는 메모리 영역.
* JVM에서 관리하며 프로그래머가 작성한 상수에 대해서 최우선적으로 찾아보고 없으면 상수풀에 추가한 이후 그 주소값을 리턴.

## 5. jdbc

* 자바에서 데이터베이스를 접속할 수 있도록 해주는 자바 API.
* JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트 하는 방법들을 제공.

## 6. 직렬화

* 자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동.
* 객체를 바이트 배열로 변환하는 것을 직렬화라고 함.
* 반대 과정을 역직렬화라고 함.

## 7. serialVersionUID를 선언하는 이유?

* JVM은 직렬화나 역직렬화를 하는 시점에 클래스에 대해 version 번호를 부여.
* 클래스의 정의가 바뀌면 version 번호도 새로 할당.
* 직렬화, 역직렬화 과정에서 클래스 버전을 확인하기 위한 용도.

## 8. 리플렉션

* 컴파일 시간이 아닌 실행 시간에 동적으로 특정 클래스의 정보를 객체화를 통해 추출해 해는 프로그래밍 기법.

## 9. 클래스 멤버 변수의 초기화 순서

* static 변수 선언부는 클래스가 로드 될 때 제일 먼저 초기화
* 필드 선언부는 객체가 생성될 때, heap 메모리에 올라가고 그 다음 생성자 block이 초기화.

## 10. Servlet과 JSP

* Servlet은 서버에서 웹페이지 등을 동적으로 생성하거나 데이터 처리를 수행하기 위해 자바로 작성된 프로그램.
* JSP는 html 내부에 자바 코드를 삽입하는 형식 ( 서블릿의 단점을 보완하기 위해 만든 서블릿 기반의 스크립트 기술)
* 서블릿을 작성하지 않고 간편하게 웹 프로그래밍을 구현.
* 서블릿을 이용하면 화면 인터페이스 구현에 너무 많은 코드를 필요로 하는 비효율적인 측면이 있다.

## 11. 제너릭

* 클래스 내부에서 사용하는 데이터의 타입을 클래스의 인스턴스를 생성할 때 결정하는 것.
* 객체의 타입을 컴파일 시점에 체크하기 떄문에 타입 안정성을 높이고 형 변환의 번거로움을 줄임.

## 12. 컬렉션 클래스에서 제너릭을 사용하는 이유

* 컴파일러는 특정한 타입만 포함될 수 있도록 컬렉션을 제한.
* 컬렉션 클래스에 저장되는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 모든 예외를 컴파일 타임에 잡아낼 수 있음.

* 컬렉션 : 데이터의 집합, 그룹

## 13. pojo

* 특정 기술에 종속되어 있지 않은 순수한 자바 객체.
* 특정 기술에 종속하게 된다면 확장성이 떨어지는 단점이 있기 때문에 pojo 개념이 등장함.

## 14. 박싱과 언박싱

* 박싱 : 프리미티브 타입을 Wrapper 클래스로 변환
* 언박싱 : Wrapper 클래스를 프리미티브 타입으로 변환
* 제네릭은 primitive type을 받지 않기 때문에 wrapper 클래스를 이용해야함.

* primitive type 쓰는 이유?
* 자바는 모든 객체를 힙에 저장하는데 힙은 스택보다 상대적으로 속도가 느림.

## 15. 데드락

* 둘 이상의 쓰레드가 lock을 획득하기 위해 기다리는데 이 lock을 잡고 있는 쓰레드도 똑같이 다른 lock을 기다리며 서로 블록 상태에 놓이는 것.
* 다수의 쓰레드가 같은 lock을 동시에 다른 명령에 의해 획득하려 할 때 발생.

* 해결 방법
* 우선 순위를 선정해 자원을 선점하도록 함, 공유 불가능한 상호 배제 조건을 제거

* 프로그램 : 특정 작업을 수행하는 소프트웨어
* 프로세스 : 프로그램이 실행되어 메모리나 cpu와 같은 자원을 할당 받음.
* 스레드 : 프로세스를 구성하는 하나의 단위.

* lock : 쓰레드 동기화 메커니즘, 모든 객체가 갖고 있음

## 16. 상속과 컴포지션의 차이

* 상속 : 자식 클래스가 부모 클래스의 메소드와 필드를 물려받는 것.

* 컴포지션 : 기존 클래스를 확장하는 대신 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조.
* 새로운 클래스는 기존 클래스의 영향이 적어지고 새로운 메소드를 추가해도 안전.

* 언제 상속을 사용하는가?
* is-a 관계인지 확인, A가 와인이고 B가 레드 와인이라면 "B가 A인가?" 확인.

## 17. JVM의 역할

* 자바를 실행하기 위한 가상 기계, 자바와 운영체제 사이의 중계자 역할.
* 자바 컴파일러가 자바 소스 파일을 컴파일하면 .class라는 byte code로 변환. 이 byte code는 기계어가 아니므로 운영체제에서 실행되지 않음.
* 운영체제가 이해할 수 있도록 해석해주는 것이 JVM

## 18. interface와 abstarct 비교

* interface : 추상 클래스이며 추상 메소드와 상수만 변수로 갖는다. 상속 관계가 없는 클래스간 서로 공통되는 로직을 구현하여 쓸 수 있음.
* abstarct : 추상 메소드를 하나 이상 가진 클래스이며 자신의 생성자로 객체 생성이 불가능.
* 하위 클래스를 참조하여 상위 클래스의 객체를 생성해 하위 클래스를 제어하기 위해 사용.

## 19. 다형성

* 하나의 메소드나 클래스가 다양한 방법으로 동작하는 것을 의미.(오버로딩, 오버라이딩)
* 하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것.

## 20. hashmap의 시간복잡도

* hashmap : hashing을 배열의 index로 해 그 곳에 바로 집어넣기 때문에 O(1)
* hashing : key값을 hash 알고리즘을 통해 산술적인 연산을 적용하는 것.

## 21. 동적할당

* 실행 시간(runtime)동안 사용할 메모리 공간을 할당하는 것.

## 22. 동기화 객체

* 사용자 모드 동기화용 객체

* 크리티컬 섹션
* 내부 구조가 단순해 동기화 처리에 있어 속도가 빠름. 동일한 프로세스 내에서만 사용 가능.
* 프로세스 하나에 여러 개의 스레드가 공유 리소스에 접근할 때 베타적 제어를 하기 위한 구조.

* 운영체제가 제공하는 동기화용 커널 객체 ( 크리티컬 섹션보다 느림, 훨씬 더 복잡한 동기화에 사용됨)
* 일정 시점에 2가지 상태 중 1가지를 가짐.
* 신호 상태 : 스레드의 실행을 허가한 상태
* 비신호 상태 : 스레드의 실행을 허가하지 않은 상태, 신호상태가 될 때까지 스레드는 블록된다.

* 뮤텍스
* 크리티컬 세션이 쓰이는 곳에 대신 사용될 수 있음.
* 프로세스 간에도 사용할 수 있다는 장점, 그만큼 속도는 느림.(같은 프로세스 내에서는 크리티컬 세션과 차이 거의 없음)
* 어떤 스레드에게 소유가 된다면 뮤텍스는 비신호 상태.

* 세마포어
* 여러 스레드나 프로세스가 특정 리소스에 접근할 수 있도록 임의로 허용치를 정하는 것.
