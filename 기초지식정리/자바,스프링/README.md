# 1. OOP란?

* 현실 세계를 프로그래밍으로 옮겨와 사물을 객체로 보고 그 객체의 특징과 기능을 뽑아 프로그래밍하는 기법.
* 객체를 연결시켜 프로그래밍하면 상속, 캡슐화, 다형성을 이용해 코드 재사용성을 증가시키고 유지보수를 감소시켜주는 장점.

## 상속

* 자식 클래스가 부모 클래스의 필드와 메소드를 물려받는 것.
* private 필드와 메소드는 상속 불가.
* 중복된 코드 줄일 수 있고, 유지보수가 편리

## 다형성

* 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것.(오버로딩, 오버라이딩)
* 하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것.

## 캡슐화

* 객체접근에 있어서 정보를 숨기고 객체의 연산을 통해서만 접근이 가능하게 하는 것.
* 유지보수나 확장시 캡슐화를 통해 오류의 범위를 최소화 할 수 있다.

# 2. 자바의 메모리 영역

* static 영역
* static 변수, 전역 변수, 코드에서 사용되는 클래스 정보들이 올라감.
* 프로그램 종료시 까지 메모리에 남아있게 된다.

* 스택
* 지역 변수, 메소드 등이 할당되는 영역

* 힙
* new 연산자를 통해 동적할당된 객체들이 저장되고, 메모리는 가비지 컬렉션에 의해 관리.

## static

* static 영역에 변수가 올라가 프로그램 종료시까지 메모리에 남아있게 됨.
* 객체의 생성 없이 바로 접근 가능.

## JVM

* 자바와 운영체제 사이의 중계자 역할을 함, 자바가 운영체제 종류에 상관없이 돌아갈 수 있도록 함.
* 메모리를 자동으로 관리(GC)

* 자바 실행 과정
* Java Compiler에 의해 Java Source(.java) 파일은 Byte Code(.class)로 변환.
* Class Loader는 변환된 Byte Code 파일을 JVM 내로 class를 로드.
* Excution Engine은 JVM 메모리에 배치된 Byte Code들을 명령어 단위로 실행.
* GC는 더 이상 참조되지 않거나 null인 객체의 메모리를 해제시켜 공간 확보.
* Runtime Data Area는 JVM 메모리로 Java Application이 실행하면서 할당받은 메모리영역이다.

## 가비지 컬렉터

* Java Application은 JVM 위에서 구동, JVM에서는 Java Application이 사용하는 메모리를 관리하는데 JVM의 기능 중
더 이상 사용하지 않는 객체를 청소하여 공간을 확보하는 가비지 컬렉터가 있다.

* GC 과정
* 객체가 생성되어 Eden 영역에 올라감.
* Eden 영역이 꽉 차면 Servior 영역으로 넘어감, 객체의 크기가 Servior 영역보다 크다면 Old 영역으로 이동
* Old 영역에 들어간 객체는 풀 GC, 메이저 GC가 발생하지 않는한 GC되지 않음.

* 풀 GC : 메모리 전체를 대상으로 하는 GC
* 메이저 GC : Old, Perm 영역에서 발생하는 GC
* 마이너 GC : Young 영역에서 발생하는 GC

* GC 방식
* Serial Collector
* 하나의 CPU로 Young 영역과 Old 영역을 연속적으로 처리, 컬렉션이 수행될 때 애플리케이션이 정지.
* Old 영역에서 쓰레기 객체를 한 곳으로 모아 삭제.

* Parallel Collector
* 다른 CPU가 GC의 진행시간 동안 대기 상태로 남아 있는 것을 최소화
* Serial Collector의 Young 영역에서 진행하는 컬렉션을 병렬 방식으로 처리해 GC의 부하를 줄이고 성능을 향상.

## 3. 인터페이스

* 모든 메소드가 추상 메소드로 이루어진 클래스.
* 공동 작업시 충동을 방지하기 위해 사용한다.
* A,B가 각각 a번역, b번역 메소드 코드를 작성할 때 인터페이스를 상속받아 사용하게 된다면 클래스의 이름만 알고 있다면
번역 메소드를 호출했을 때 어떤 번역 기능을 하는지 기대할 수 있다는 것.

* 교체 용이
* 다른 방식으로 바꾸고 싶을 때, 클래스를 개발해서 이름만 교체하면 되므로 간편하다.

* 다중 상속
* 필요한 인터페이스를 상속 받아서 구현하면 여러 기능들을 구조적으로 포함.

## 4. 메모리 상수풀 영역

* 힙 영역의 고정 영역에 생성되어 프로그램 종료시까지 계속 유지되는 메모리 영역.
* JVM에서 관리하며 프로그래머가 작성한 상수에 대해서 최우선적으로 찾아보고 없으면 상수풀에 추가한 이후 그 주소값을 리턴.

## 5. jdbc

* 자바에서 데이터베이스를 접속할 수 있도록 해주는 자바 API.
* JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트 하는 방법들을 제공.

## 6. 직렬화

* 자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동.
* 객체를 바이트 배열로 변환하는 것을 직렬화라고 함.
* 반대 과정을 역직렬화라고 함.

## 7. serialVersionUID를 선언하는 이유?

* JVM은 직렬화나 역직렬화를 하는 시점에 클래스에 대해 version 번호를 부여.
* 클래스의 정의가 바뀌면 version 번호도 새로 할당.
* 직렬화, 역직렬화 과정에서 클래스 버전을 확인하기 위한 용도.

## 8. 리플렉션

* 컴파일 시간이 아닌 실행 시간에 동적으로 특정 클래스의 정보를 객체화를 통해 추출해 해는 프로그래밍 기법.

## 9. 클래스 멤버 변수의 초기화 순서

* static 변수 선언부는 클래스가 로드 될 때 제일 먼저 초기화
* 필드 선언부는 객체가 생성될 때, heap 메모리에 올라가고 그 다음 생성자 block이 초기화.

## 10. Servlet과 JSP

* Servlet은 서버에서 웹페이지 등을 동적으로 생성하거나 데이터 처리를 수행하기 위해 자바로 작성된 프로그램.
* JSP는 html 내부에 자바 코드를 삽입하는 형식 ( 서블릿의 단점을 보완하기 위해 만든 서블릿 기반의 스크립트 기술)
* 서블릿을 작성하지 않고 간편하게 웹 프로그래밍을 구현.
* 서블릿을 이용하면 화면 인터페이스 구현에 너무 많은 코드를 필요로 하는 비효율적인 측면이 있다.

## 11. 제너릭
