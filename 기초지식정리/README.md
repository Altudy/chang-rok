<h1>백엔드 관련 기초 지식을 정리한 페이지 입니다.</h1>


※참고 : **[백엔드로드맵](https://github.com/devJang/developer-roadmap)**

## 1. 인터넷

### 1-1. 인터넷은 어떻게 작동할까?
```
1) 인터넷은 모든 컴퓨터를 연결하고 어떤 일이 있어도 연결 상태를 유지할 수 있는 방법을 찾는 방법.
2) 두 개의 컴퓨터가 통신을 하면서 네트워크를 구성, 컴퓨터가 늘어날수록 케이블을 연결하면 복잡해진다.
3) 컴퓨터를 라우터에 연결하고 라우터끼리 연결하면서 확장한다.
4) 먼 곳에 통신을 하기 위해 모뎀을 이용해 네트워크를 전화 시설에 연결한다.(ISP 네트워크를 통해 연결)
5) 모든 컴퓨터에는 고유 IP주소가 있고 우리는 이를 통해 컴퓨터를 찾는다.
```

### 1-2. HTTP는 무엇인가?
```
1) hyertext transfer protocol로 html문서를 주고 받는데 쓰인다.(클라이언트와 서버 사이에 이루어지는 요청/응답 프로토콜)
2) 주로 TCP를 사용하고, HTTP/3부터는 UDP를 사용하며 port 80번을 쓴다.
```

### 1-3. 브라우저와 동작 원리
```
1) 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시
2) 자원은 html문서 또는 pdf,이미지 나 다른 형태, 자원의 주소는 uri에 의해 정해진다.
3) 렌데링 엔진으로 요청한 내용을 서버로부터 받아 브라우저 화면에 표시
4) html,xml,이미지를 표시할 수 있으며 플러그인이나 확장 기능을 이용해 pdf와 같은 유형도 표시 가능
5) 동작 원리는 다음과 같다.
html 문서를 파싱 > 브라우저 화면에 렌더링하기 위해 다루기 쉬운 구조로 바꿈 > css파일 파싱 > 렌더트리 구축 > 렌더트리 배치
> 렌더트리 그리기
5-1) 좀 더 나은 사용자 경험을 위해 모든 html을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작.
```

### 1-4. DNS와 작동 원리
```
1) dns랑 사람이 읽을 수 있는 이름을 ip주소로 변환하여 컴퓨터가 서로 통신할 수 있도록 한다.
2) 인터넷의 dns 시스템은 이름과 숫자 간의 매핑을 관리.
3) dns 서버는 이름에 대한 요청을 ip주소로 변환하여 사용자가 도메인 이름을 웹 브라우저에 입력할 때 해당 사용자를 어떤 서버에 연결할
것인지 제어, 이를 쿼리라고 함.

4) 작동 원리는 다음과 같다.
4-1) 웹 브라우저에 A를 입력하면 local dns에게 A라는 hostname에 대한 ip주소를 질의하여 local dns에 없으면 1차적으로 Root dns에 질의.
4-2) root dns로부터 com 도메인을 관리하는 tld(top-level domain) 서버 정보를 전달 받음.
4-3) tld에 A를 질의하면 tld에서 name.com 도메인을 관리하는 dns 서버 정보를 전달.
4-4) name.com 도메인을 관리하는 dns에 ip 주소를 질의하여 local dns가 ip주소를 응답받음.
4-5) local dns는 ip주소를 캐싱하고 ip주소를 사용자에게 전달.
```

### 1-5. 도메인 네임은 무엇인가? & 호스팅은 무엇인가?
```
1) 도메인네임 : 네트워크 상에서 원하는 호스트를 가리키는 이름
2) 호스팅 : 서버의 전체 혹은 일부를 이용할 수 있도록 임대해주는 서비스(즉, 개인이 서버를 관리하기보다는 전문 업체의 호스팅 서비스를 사용)
2-1) 웹 호스팅 : 여러 고객이 하나의 서버를 함께 사ㅇ용.
2-2) 서버 호스팅 : 고객이 단독 서버를 사용하는 형태.
2-3) 클라우드 서버 : 서버 호스팅을 가상화 한 것, 가상 서버를 단독으로 사용할 수 있는 형태. 고객이 필요할 때마다 서버 자원을 늘리거나 축소하여
유연하게 서버를 이용 가능.
```

## 2. 기본적인 프론트엔드 지식
```
* html,css,javascript는 실습을 통해 기초 지식 습득. javascript만 일부 내용을 정리 하고자 한다.

1) JavaScript Event Loop
1-1) Javascript Engine : Javascript로 작성한 코드를 해석하고 실행하는 인터프리터다. Call stack, Task Queue, Heap 3영역으로 나뉜다.

* Call stack
* Javascript는 단 하나의 call stack을 사용한다. 즉, 하나의 함수가 실행되면 이 함수의 실행이 끝날 때까지 다른 어떤 task도 수행될 수 없다.

* Heap
* 동적으로 생성된 객체는 힙에 할당된다.

* Task Queue(Event Queue)
* 처리해야 하는 Task들을 임시 저장하는 대기 큐. Call stack이 비어졌을 때, 먼저 대기열에 들어온 순서대로 실행된다.
* Javascript에서 비동기로 호출되는 함수들은 Call stack에 쌓이지 않고 Task Queue에 enqueue된다. 이벤트에 의해 실행되는 함수들이 비동기로 실행.
* Javascript Engine이 아닌 Web API 영역에 따로 정의되어 있는 함수들은 비동기로 실행.
* Event loop는 현재 실행중인 task가 없는지 task queue에 task가 있는지를 반복적으로 확인

1-2) Javascript 비동기 처리 과정
* 비동기 작업으로 등록되는 작업은 task와 microtask, animationFrame 작업으로 구분된다.
* 처리 순서는 micro > animationFrame > task 순이다.
* microtask가 처리된 이후 animationFrame이 호출되고 이후 브라우저 렌더링이 발생한다.
* microtask에는 MutationObserver와 Promise가 해당된다.

2) Hoisting(끌어올리는 것)
* 변수의 정의가 그 범위에 따라 선언과 할당으로 분리되는 것.
* 선언문은 Javascript Engine 구동시 가장 최우선으로 해석하므로 hoisting되고, 할당 구문은 런타임 과정에서 이루어지기 떄문에 hoisting되지 않음.
ex) 함수 선언이 함수 실행 부분보다 뒤에 있더라도 Javascript Engine이 함수 선언을 끌어올리는 것.

3) Closure
* 두 개의 함수로 만들어진 환경으로 이루어진 특별한 객체의 한 종류, 환경은 클로저가 생성될 때 그 범위에 있던 여러 지역 변수들이 포함된 context
* 클로저를 통해서 Javascript에 private,public 속성/메소드를 구현할 수 있다.
* 외부 함수 호출이 종료되더라도 외부 함수의 지역 변수 및 변수 스코프 객체의 체인 관계를 유지할 수 있는 구조.
* 외부 함수에 의해 반환되는 내부 함수.

4) this
* arguments라는 유사 배열 객체와 함께 함수 내부로 암묵적으로 전달되는 것.
* 객체의 메서드를 호출할 때, A.B일 때 B 함수 내부의 this는 A를 가리킨다.
* 함수를 호출할 때, A.B일 때 A가 전역 객체가 되므로 this는 전역 객체에 바인딩 된다.
* 생성자 함수를 통해 객체를 생성할 때, new 키워드를 통해서 호출된 함수 내부에서의 this는 객체 자신이 된다.
* apply,call,bind를 통한 호출
* bind는 함수를 선언할 때, this와 파라미터를 지정.
* call과 apply는 함수를 호출할 때, this와 파라미터를 지정.
* apply는 첫번째 인자로 this를 넘겨주고 두번째 인자로 넘겨줘야 하는 파라미터를 배열의 형태로 전달.
* bind와 call은 각각의 파라미터를 하나씩 넘겨준다.

5) Promise
* 대부분의 작업들은 비동기로 이루어지는데 프론트엔드의 규모가 커지면서 코드의 복잡도가 높아지는 상황 발생.
* Promise 패턴을 사용하여 비동기 작업을 순차적으로 진행하거나, 병렬로 진행하여 컨트롤이 수월해짐.
* 또한, 예외처리에 대한 구조가 존재하기 때문에 오류 처리 등에 대해 보다 가시적으로 관리 가능.

* Promise를 사용하면 비동기 메서드에서 동기 메서드처럼 값을 반환할 수 있다.
* 최종 결과를 반환하는 것이 아닌, Promise를 반환해서 미래의 어떤 시점에 결과를 제공.
* 대기,이행,거부 중 하나의 상태를 가짐.
* new Promise(function(resolve,reject) ~~~ , 성공시 resolve 수행, 실패시 reject 수행.
* .then(fn) 메서드를 통해 비동기처리가 완료된 시점에서 fn 함수를 실행.
* catch()를 이용해 에러 처리, then()의 두 번째 인자로 에러 처리.

6) Async/Await
* 비동기 코드를 작성하는 새로운 방법, Promise에 만족하지 않고 더 훌륭한 방법을 고안해냄.
* function 앞에 async를 붙여주고, function 내부의 promise를 반환하는 비동기 처리 함수 앞에 await를 붙여준다.
* Promise보다 비동기 코드의 겉모습이 더 깔끔하다는 장점.

7) Arrow function
* 기존의 function 표현방식보다 간결하게 함수를 표현할 수 있다. 항상 익명이며 자신의 this,arguments,super,new.target을 바인딩하지 않음.
* 그래서 생성자로 사용할 수 없다.
```
※참고: [JavaScript](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/JavaScript)
